
@inproceedings{mantyla_taxonomy_2003,
	title = {A taxonomy and an initial empirical study of bad smells in code},
	doi = {10.1109/ICSM.2003.1235447},
	booktitle = {International {Conference} on {Software} {Maintenance}, 2003. {ICSM} 2003. {Proceedings}.},
	author = {Mantyla, M. and Vanhanen, J. and Lassenius, C.},
	month = sep,
	year = {2003},
	keywords = {Internet, bad code smells, Cloning, code quality, correlations, empirical study, Logic, object-oriented context, object-oriented programming, program compilers, Programming, software maintenance, Software maintenance, Software measurement, software performance evaluation, software quality, Software quality, Software systems, taxonomy, Taxonomy, Visualization},
	pages = {381--384},
	file = {Mantyla et al. - 2003 - A taxonomy and an initial empirical study of bad s.pdf:/home/rodger/Zotero/storage/E3HQT7RF/Mantyla et al. - 2003 - A taxonomy and an initial empirical study of bad s.pdf:application/pdf}
}

@inproceedings{arcoverde_understanding_2011,
	address = {New York, NY, USA},
	series = {{WRT} '11},
	title = {Understanding the {Longevity} of {Code} {Smells}: {Preliminary} {Results} of an {Explanatory} {Survey}},
	isbn = {978-1-4503-0579-2},
	url = {http://doi.acm.org/10.1145/1984732.1984740},
	doi = {10.1145/1984732.1984740},
	booktitle = {Proceedings of the 4th {Workshop} on {Refactoring} {Tools}},
	publisher = {ACM},
	author = {Arcoverde, Roberta and Garcia, Alessandro and Figueiredo, Eduardo},
	year = {2011},
	note = {event-place: Waikiki, Honolulu, HI, USA},
	keywords = {empirical study, code smells, refactoring},
	pages = {33--36},
	file = {Arcoverde et al. - 2011 - Understanding the Longevity of Code Smells Prelim.pdf:/home/rodger/Zotero/storage/X8X8XNAT/Arcoverde et al. - 2011 - Understanding the Longevity of Code Smells Prelim.pdf:application/pdf}
}

@inproceedings{yamashita_developers_nodate,
	title = {Do developers care about code smells? {An} exploratory survey},
	doi = {10.1109/WCRE.2013.6671299},
	author = {Yamashita, A. and Moonen, L.},
	month = oct,
	pages = {242--251},
	file = {Yamashita and Moonen - Do developers care about code smells An explorato.pdf:/home/rodger/Zotero/storage/YXU7ZHR4/Yamashita and Moonen - Do developers care about code smells An explorato.pdf:application/pdf}
}

@article{garousi_smells_2018,
	title = {Smells in software test code: {A} survey of knowledge in industry and academia},
	volume = {138},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121217303060},
	doi = {https://doi.org/10.1016/j.jss.2017.12.013},
	abstract = {As a type of anti-pattern, test smells are defined as poorly designed tests and their presence may negatively affect the quality of test suites and production code. Test smells are the subject of active discussions among practitioners and researchers, and various guidelines to handle smells are constantly offered for smell prevention, smell detection, and smell correction. Since there is a vast grey literature as well as a large body of research studies in this domain, it is not practical for practitioners and researchers to locate and synthesize such a large literature. Motivated by the above need and to find out what we, as the community, know about smells in test code, we conducted a ‘multivocal’ literature mapping (classification) on both the scientific literature and also practitioners’ grey literature. By surveying all the sources on test smells in both industry (120 sources) and academia (46 sources), 166 sources in total, our review presents the largest catalogue of test smells, along with the summary of guidelines/techniques and the tools to deal with those smells. This article aims to benefit the readers (both practitioners and researchers) by serving as an “index” to the vast body of knowledge in this important area, and by helping them develop high-quality test scripts, and minimize occurrences of test smells and their negative consequences in large test automation projects.},
	journal = {Journal of Systems and Software},
	author = {Garousi, Vahid and Küçük, Barış},
	year = {2018},
	keywords = {Automated testing, Multivocal literature mapping, Software testing, Survey, Systematic mapping, Test anti-patterns, Test automation, Test scripts, Test smells},
	pages = {52 -- 81},
	file = {Garousi and Küçük - 2018 - Smells in software test code A survey of knowledg.pdf:/home/rodger/Zotero/storage/8IJDPDPI/Garousi and Küçük - 2018 - Smells in software test code A survey of knowledg.pdf:application/pdf}
}

@article{yoshioka_survey_2008,
	title = {A survey on security patterns},
	issn = {1349-8614, 1349-8606},
	url = {http://www.nii.ac.jp/pi/n5/5_35.html},
	doi = {10.2201/NiiPi.2008.5.5},
	abstract = {Security has become an important topic for many software systems. Security patterns are reusable solutions to security problems. Although many security patterns and techniques for using them have been proposed, it is still difﬁcult to adapt security patterns to each phase of software development. This paper provides a survey of approaches to security patterns. As a result of classifying these approaches, a direction for the integration and future research topics is illustrated.},
	language = {en},
	number = {5},
	urldate = {2019-09-22},
	journal = {Progress in Informatics},
	author = {Yoshioka, Nobukazu and Washizaki, Hironori and Maruyama, Katsuhisa},
	month = mar,
	year = {2008},
	pages = {35},
	annote = {This is a security pattern paper not an anti pattern paper, also very old.},
	file = {Yoshioka et al. - 2008 - A survey on security patterns.pdf:/home/rodger/Zotero/storage/7SQCG3TU/Yoshioka et al. - 2008 - A survey on security patterns.pdf:application/pdf}
}

@article{sharma_survey_2018,
	title = {A survey on software smells},
	volume = {138},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121217303114},
	doi = {https://doi.org/10.1016/j.jss.2017.12.034},
	abstract = {Context Smells in software systems impair software quality and make them hard to maintain and evolve. The software engineering community has explored various dimensions concerning smells and produced extensive research related to smells. The plethora of information poses challenges to the community to comprehend the state-of-the-art tools and techniques. Objective We aim to present the current knowledge related to software smells and identify challenges as well as opportunities in the current practices. Method We explore the definitions of smells, their causes as well as effects, and their detection mechanisms presented in the current literature. We studied 445 primary studies in detail, synthesized the information, and documented our observations. Results The study reveals five possible defining characteristics of smells — indicator, poor solution, violates best-practices, impacts quality, and recurrence. We curate ten common factors that cause smells to occur including lack of skill or awareness and priority to features over quality. We classify existing smell detection methods into five groups — metrics, rules/heuristics, history, machine learning, and optimization-based detection. Challenges in the smells detection include the tools’ proneness to false-positives and poor coverage of smells detectable by existing tools.},
	journal = {Journal of Systems and Software},
	author = {Sharma, Tushar and Spinellis, Diomidis},
	year = {2018},
	keywords = {Software quality, Antipatterns, Code smells, Maintainability, Smell detection tools, Software smells, Technical debt},
	pages = {158 -- 173},
	annote = {Kent Beck coined the term code smell.},
	file = {Sharma and Spinellis - 2018 - A survey on software smells.pdf:/home/rodger/Zotero/storage/H23FHZG6/Sharma and Spinellis - 2018 - A survey on software smells.pdf:application/pdf}
}

@inproceedings{gopstein_understanding_2017,
	address = {New York, NY, USA},
	series = {{ESEC}/{FSE} 2017},
	title = {Understanding {Misunderstandings} in {Source} {Code}},
	isbn = {978-1-4503-5105-8},
	url = {http://doi.acm.org/10.1145/3106237.3106264},
	doi = {10.1145/3106237.3106264},
	booktitle = {Proceedings of the 2017 11th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Gopstein, Dan and Iannacone, Jake and Yan, Yu and DeLong, Lois and Zhuang, Yanyan and Yeh, Martin K.-C. and Cappos, Justin},
	year = {2017},
	note = {event-place: Paderborn, Germany},
	keywords = {Program Understanding, Programming Languages},
	pages = {129--139},
	file = {Gopstein et al. - 2017 - Understanding Misunderstandings in Source Code.pdf:/home/rodger/Zotero/storage/9MFMG3I9/Gopstein et al. - 2017 - Understanding Misunderstandings in Source Code.pdf:application/pdf}
}

@article{singh_systematic_2018,
	title = {A systematic literature review: {Refactoring} for disclosing code smells in object oriented software},
	volume = {9},
	issn = {2090-4479},
	url = {http://www.sciencedirect.com/science/article/pii/S2090447917300412},
	doi = {https://doi.org/10.1016/j.asej.2017.03.002},
	abstract = {Context Reusing a design pattern is not always in the favor of developers. Thus, the code starts smelling. The presence of “Code Smells” leads to more difficulties for the developers. This racket of code smells is sometimes called Anti-Patterns. Objective The paper aimed at a systematic literature review of refactoring with respect to code smells. However the review of refactoring is done in general and the identification of code smells and anti-patterns is performed in depth. Method A systematic literature survey has been performed on 238 research items that includes articles from leading Conferences, Workshops and premier journals, theses of researchers and book chapters. Results Several data sets and tools for performing refactoring have been revealed under the specified research questions. Conclusion The work done in the paper is an addition to prior systematic literature surveys. With the study of paper the attentiveness of readers about code smells and anti-patterns will be enhanced.},
	number = {4},
	journal = {Ain Shams Engineering Journal},
	author = {Singh, Satwinder and Kaur, Sharanpreet},
	year = {2018},
	keywords = {Code smells, Anti-patterns, Refactoring},
	pages = {2129 -- 2151},
	file = {Singh and Kaur - 2018 - A systematic literature review Refactoring for di.pdf:/home/rodger/Zotero/storage/LNW3WWX6/Singh and Kaur - 2018 - A systematic literature review Refactoring for di.pdf:application/pdf}
}

@inproceedings{li_dlfinder:_2019,
	address = {Piscataway, NJ, USA},
	series = {{ICSE} '19},
	title = {Dlfinder: {Characterizing} and {Detecting} {Duplicate} {Logging} {Code} {Smells}},
	url = {https://doi.org/10.1109/ICSE.2019.00032},
	doi = {10.1109/ICSE.2019.00032},
	booktitle = {Proceedings of the 41st {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Li, Zhenhao and Chen, Tse-Hsun (Peter) and Yang, Jinqiu and Shang, Weiyi},
	year = {2019},
	note = {event-place: Montreal, Quebec, Canada},
	keywords = {empirical study, code smell, duplicate log, log, static analysis},
	pages = {152--163},
	file = {Li et al. - 2019 - Dlfinder Characterizing and Detecting Duplicate L.pdf:/home/rodger/Zotero/storage/SH6RJUWB/Li et al. - 2019 - Dlfinder Characterizing and Detecting Duplicate L.pdf:application/pdf}
}

@inproceedings{haque_causes_2018,
	address = {New York, NY, USA},
	series = {{ACMSE} '18},
	title = {Causes, {Impacts}, and {Detection} {Approaches} of {Code} {Smell}: {A} {Survey}},
	isbn = {978-1-4503-5696-1},
	url = {http://doi.acm.org/10.1145/3190645.3190697},
	doi = {10.1145/3190645.3190697},
	booktitle = {Proceedings of the {ACMSE} 2018 {Conference}},
	publisher = {ACM},
	author = {Haque, Md Shariful and Carver, Jeff and Atkison, Travis},
	year = {2018},
	note = {event-place: Richmond, Kentucky},
	keywords = {code smell, software engineering, survey},
	pages = {25:1--25:8},
	file = {Haque et al. - 2018 - Causes, Impacts, and Detection Approaches of Code .pdf:/home/rodger/Zotero/storage/TC4XIDMH/Haque et al. - 2018 - Causes, Impacts, and Detection Approaches of Code .pdf:application/pdf}
}

@article{fontana_are_2019,
	title = {Are architectural smells independent from code smells? {An} empirical study},
	volume = {154},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121219301013},
	doi = {https://doi.org/10.1016/j.jss.2019.04.066},
	abstract = {Background. Architectural smells and code smells are symptoms of bad code or design that can cause different quality problems, such as faults, technical debt, or difficulties with maintenance and evolution. Some studies show that code smells and architectural smells often appear together in the same file. The correlation between code smells and architectural smells, however, is not clear yet; some studies on a limited set of projects have claimed that architectural smells can be derived from code smells, while other studies claim the opposite. Objective. The goal of this work is to understand whether architectural smells are independent from code smells or can be derived from a code smell or from one category of them. Method. We conducted a case study analyzing the correlations among 19 code smells, six categories of code smells, and four architectural smells. Results. The results show that architectural smells are correlated with code smells only in a very low number of occurrences and therefore cannot be derived from code smells. Conclusion. Architectural smells are independent from code smells, and therefore deserve special attention by researchers, who should investigate their actual harmfulness, and practitioners, who should consider whether and when to remove them.},
	journal = {Journal of Systems and Software},
	author = {Fontana, Francesca Arcelli and Lenarduzzi, Valentina and Roveda, Riccardo and Taibi, Davide},
	year = {2019},
	keywords = {Code smells, Technical debt, Architectural smells, Empirical analysis},
	pages = {139 -- 156},
	file = {Fontana et al. - 2019 - Are architectural smells independent from code sme.pdf:/home/rodger/Zotero/storage/V9HY6J4R/Fontana et al. - 2019 - Are architectural smells independent from code sme.pdf:application/pdf}
}

@article{walter_code_2018,
	title = {Code smells and their collocations: {A} large-scale experiment on open-source systems},
	volume = {144},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121218301109},
	doi = {https://doi.org/10.1016/j.jss.2018.05.057},
	abstract = {Code smells indicate possible flaws in software design, that could negatively affect system’s maintainability. Interactions among smells located in the same classes (i.e., collocated smells) have even more detrimental effect on quality. Extracted frequent patterns of collocated smells could help to understand practical consequences of collocations. In this paper we identify and empirically validate frequent collocations of 14 code smells detected in 92 Java systems, using three approaches: pairwise correlation analysis, PCA and associative rules. To cross-validate the results, we used up to 6 detectors for each smell. Additionally, we examine and compare techniques used to extract the relationships. The contribution is three-fold: (1) we identify and empirically validate relationships among the examined code smells on a large dataset that we made publicly available, (2) we discuss how the choice of code smell detectors affects results, and (3) we analyze the impact of software domain on existence of the smell collocations. Additionally, we found that analytical methods we used to discover collocations, are complementary. Smells collocations display recurring patterns that could help prioritizing the classes affected by code smells to be refactored and developing or enhancing detectors exploiting information about collocations. They can also help the developers focusing on classes deserving more maintenance effort.},
	journal = {Journal of Systems and Software},
	author = {Walter, Bartosz and Fontana, Francesca Arcelli and Ferme, Vincenzo},
	year = {2018},
	keywords = {Code smells, Code smell detectors, Collocated smells, Inter-smell relationships, Smell interaction, Source code quality},
	pages = {1 -- 21},
	file = {Walter et al. - 2018 - Code smells and their collocations A large-scale .pdf:/home/rodger/Zotero/storage/IFES8CQ9/Walter et al. - 2018 - Code smells and their collocations A large-scale .pdf:application/pdf}
}

@article{afjehei_iperfdetector:_2019,
	title = {{iPerfDetector}: {Characterizing} and detecting performance anti-patterns in {iOS} applications},
	issn = {1573-7616},
	url = {https://doi.org/10.1007/s10664-019-09703-y},
	doi = {10.1007/s10664-019-09703-y},
	abstract = {Performance issues in mobile applications (i.e., apps) often have a direct impact on the user experience. However, due to limited testing resources and fast-paced software development cycles, many performance issues remain undiscovered when the apps are released. As found by a prior study, these performance issues are one of the most common complaints that app users have. Unfortunately, there is a limited support to help developers avoid or detect performance issues in mobile apps. In this paper, we conduct an empirical study on performance issues in iOS apps written in Swift language. To the best of our knowledge, this is the first study on performance issues of apps on the iOS platform. We manually studied 225 performance issues that are collected from four open source iOS apps. We found that most performance issues in iOS apps are related to inefficient UI design, memory issues, and inefficient thread handling. We also manually uncovered four performance anti-patterns that recurred in the studied issue reports. To help developers avoid these performance anti-patterns in the code, we implemented a static analysis tool called iPerfDetector. We evaluated iPerfDetector on eight open source and three commercial apps. iPerfDetector successfully detected 34 performance anti-pattern instances in the studied apps, where 31 of them are already confirmed and accepted by developers as potential performance issues. Our case study on the performance impact of the anti-patterns shows that fixing the anti-pattern may improve the performance (i.e., response time, GPU, or CPU) of the workload by up to 80\%.},
	journal = {Empirical Software Engineering},
	author = {Afjehei, Sara Seif and Chen, Tse-Hsun (Peter) and Tsantalis, Nikolaos},
	month = apr,
	year = {2019},
	file = {Afjehei et al. - 2019 - iPerfDetector Characterizing and detecting perfor.pdf:/home/rodger/Zotero/storage/LJ5Z7SFD/Afjehei et al. - 2019 - iPerfDetector Characterizing and detecting perfor.pdf:application/pdf}
}

@inproceedings{tian_how_2019,
	title = {How {Developers} {Discuss} {Architecture} {Smells}? {An} {Exploratory} {Study} on {Stack} {Overflow}},
	doi = {10.1109/ICSA.2019.00018},
	booktitle = {2019 {IEEE} {International} {Conference} on {Software} {Architecture} ({ICSA})},
	author = {Tian, F. and Liang, P. and Babar, M. A.},
	month = mar,
	year = {2019},
	keywords = {software maintenance, software quality, Software systems, Architecture Refactoring, Architecture Smell, Architecture Smells, Computer architecture, Computer science, Data mining, detecting refactoring ASs, developers discuss architecture Smells, Filtering, grounded theory method, Quality Attribute, software architecture, Stack Overflow, system quality attributes, system reusability, system testability, Tools},
	pages = {91--100},
	file = {Tian et al. - 2019 - How Developers Discuss Architecture Smells An Exp.pdf:/home/rodger/Zotero/storage/3B3AHVPC/Tian et al. - 2019 - How Developers Discuss Architecture Smells An Exp.pdf:application/pdf}
}

@inproceedings{vassallo_automated_2019,
	address = {Piscataway, NJ, USA},
	series = {{ICSE} '19},
	title = {Automated {Reporting} of {Anti}-patterns and {Decay} in {Continuous} {Integration}},
	url = {https://doi.org/10.1109/ICSE.2019.00028},
	doi = {10.1109/ICSE.2019.00028},
	booktitle = {Proceedings of the 41st {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Vassallo, Carmine and Proksch, Sebastian and Gall, Harald C. and Di Penta, Massimiliano},
	year = {2019},
	note = {event-place: Montreal, Quebec, Canada},
	keywords = {anti-pattern, CI-Decay, CI-Smell, continuous integration, detection},
	pages = {105--115},
	file = {Vassallo et al. - 2019 - Automated Reporting of Anti-patterns and Decay in .pdf:/home/rodger/Zotero/storage/I3A6GPN9/Vassallo et al. - 2019 - Automated Reporting of Anti-patterns and Decay in .pdf:application/pdf}
}

@book{taibi_microservices_2019,
	title = {Microservices {Anti} {Patterns}: {A} {Taxonomy}},
	author = {Taibi, Davide and Lenarduzzi, Valentina and Pahl, Claus},
	year = {2019},
	file = {Taibi et al. - 2019 - Microservices Anti Patterns A Taxonomy.pdf:/home/rodger/Zotero/storage/5IEGVEGJ/Taibi et al. - 2019 - Microservices Anti Patterns A Taxonomy.pdf:application/pdf}
}

@inproceedings{tahir_can_2018,
	address = {New York, NY, USA},
	series = {{EASE}'18},
	title = {Can {You} {Tell} {Me} if {It} {Smells}?: {A} {Study} on {How} {Developers} {Discuss} {Code} {Smells} and {Anti}-patterns in {Stack} {Overflow}},
	isbn = {978-1-4503-6403-4},
	url = {http://doi.acm.org/10.1145/3210459.3210466},
	doi = {10.1145/3210459.3210466},
	booktitle = {Proceedings of the 22Nd {International} {Conference} on {Evaluation} and {Assessment} in {Software} {Engineering} 2018},
	publisher = {ACM},
	author = {Tahir, Amjed and Yamashita, Aiko and Licorish, Sherlock and Dietrich, Jens and Counsell, Steve},
	year = {2018},
	note = {event-place: Christchurch, New Zealand},
	keywords = {empirical study, Code smells, Stack Overflow, anti-patterns, mining software repositories},
	pages = {68--78},
	file = {Tahir et al. - 2018 - Can You Tell Me if It Smells A Study on How Deve.pdf:/home/rodger/Zotero/storage/QUDX2IGK/Tahir et al. - 2018 - Can You Tell Me if It Smells A Study on How Deve.pdf:application/pdf}
}

@article{ibrahim_reducing_2018,
	title = {Reducing redundancy of test cases generation using code smell detection and refactoring},
	issn = {1319-1578},
	url = {http://www.sciencedirect.com/science/article/pii/S1319157818300296},
	doi = {https://doi.org/10.1016/j.jksuci.2018.06.005},
	abstract = {In software development life cycle (SDLC), the testing phase is important to test the functionalities of any software. In this phase, test cases are generated to test software functionalities. This paper presents an approach on how to detect and refactor code smells from the source codes of an Android application in order to reduce the redundancy in test case generation. Refactoring is one of the vital activities in software development and maintenance. Refactoring is a process of code alteration that aims to make structural modifications to the source code without altering any external functionality. These changes often improve software quality such as readability, execution time and maintainability. The proposed approach is then implemented and evaluated in order to determine its effectiveness in reducing the redundancy of test case generation.},
	journal = {Journal of King Saud University - Computer and Information Sciences},
	author = {Ibrahim, Rosziati and Ahmed, Maryam and Nayak, Richi and Jamel, Sapiee},
	year = {2018},
	keywords = {Refactoring, Code smell detection, Duplicate code smell, Lazy class, Small method},
	file = {Ibrahim et al. - 2018 - Reducing redundancy of test cases generation using.pdf:/home/rodger/Zotero/storage/298RRE2V/Ibrahim et al. - 2018 - Reducing redundancy of test cases generation using.pdf:application/pdf}
}

@article{brabra_semantic_2019,
	title = {On semantic detection of cloud {API} (anti)patterns},
	volume = {107},
	issn = {0950-5849},
	url = {http://www.sciencedirect.com/science/article/pii/S095058491830226X},
	doi = {https://doi.org/10.1016/j.infsof.2018.10.012},
	abstract = {Context Open standards are urgently needed for enabling software interoperability in Cloud Computing. Open Cloud Computing Interface (OCCI) provides a set of best design principles to create interoperable REST management APIs. Although OCCI is the only standard addressing the management of any kind of cloud resources, it does not support a range of best principles related to REST design. This often worsens REST API quality by decreasing their understandability and reusability. Objective We aim at assisting cloud developers to enhance their REST management APIs by providing a compliance evaluation of OCCI and REST best principles and a recommendation support to comply with these principles. Method First, we leverage patterns and anti-patterns to drive respectively the good and poor practices of OCCI and REST best principles. Then, we propose a semantic-based approach for defining and detecting REST and OCCI (anti)patterns and providing a set of correction recommendations to comply with both REST and OCCI best principles. We validated this approach by applying it on cloud REST APIs and evaluating its accuracy, usefulness and extensibility. Results We found that our approach accurately detects OCCI and REST(anti)patterns and provides useful recommendations. According to the compliance results, we reveal that there is no widespread adoption of OCCI principles in existing APIs. In contrast, these APIs have reached an acceptable level of maturity regarding REST principles. Conclusion Our approach provides an effective and extensible technique for defining and detecting OCCI and REST (anti)patterns in Cloud REST APIs. Cloud software developers can benefit from our approach and defined principles to accurately evaluate their APIs from OCCI and REST perspectives. This contributes in designing interoperable, understandable, and reusable Cloud management APIs. Thank to the compliance analysis and the recommendation support, we also contribute to improving these APIs, which make them more straightforward.},
	journal = {Information and Software Technology},
	author = {Brabra, Hayet and Mtibaa, Achraf and Petrillo, Fabio and Merle, Philippe and Sliman, Layth and Moha, Naouel and Gaaloul, Walid and Guéhéneuc, Yann-Gaël and Benatallah, Boualem and Gargouri, Faïez},
	year = {2019},
	keywords = {Analysis, Anti-pattern, Cloud computing, Detection, OCCI, Ontology, Pattern, REST, Specification},
	pages = {65 -- 82},
	file = {Brabra et al. - 2019 - On semantic detection of cloud API (anti)patterns.pdf:/home/rodger/Zotero/storage/MNZLNFIU/Brabra et al. - 2019 - On semantic detection of cloud API (anti)patterns.pdf:application/pdf}
}

@article{hussain_methodology_2019,
	title = {Methodology for the quantification of the effect of patterns and anti-patterns association on the software quality},
	volume = {13},
	doi = {10.1049/iet-sen.2018.5087},
	number = {5},
	journal = {IET Software},
	author = {Hussain, S. and Keung, J. and Sohail, M. K. and Khan, A. A. and Ahmad, G. and Mufti, M. R. and Khatak, H. A.},
	year = {2019},
	keywords = {software quality, anti-pattern classes, anti-pattern smell association, anti-patterns association, design pattern, fault density distributions, fault density quantization, multirole pattern smell association, open source projects, pattern participant classes, public domain software, software fault reduction, software fault tolerance, statistical techniques},
	pages = {414--422},
	file = {Hussain et al. - 2019 - Methodology for the quantification of the effect o.pdf:/home/rodger/Zotero/storage/5RHDNCHT/Hussain et al. - 2019 - Methodology for the quantification of the effect o.pdf:application/pdf}
}

@inproceedings{lyu_remove_2018,
	address = {New York, NY, USA},
	series = {{ISSTA} 2018},
	title = {Remove {RATs} from {Your} {Code}: {Automated} {Optimization} of {Resource} {Inefficient} {Database} {Writes} for {Mobile} {Applications}},
	isbn = {978-1-4503-5699-2},
	url = {http://doi.acm.org/10.1145/3213846.3213865},
	doi = {10.1145/3213846.3213865},
	booktitle = {Proceedings of the 27th {ACM} {SIGSOFT} {International} {Symposium} on {Software} {Testing} and {Analysis}},
	publisher = {ACM},
	author = {Lyu, Yingjun and Li, Ding and Halfond, William G. J.},
	year = {2018},
	note = {event-place: Amsterdam, Netherlands},
	keywords = {database, mobile applications, Performance optimization},
	pages = {310--321},
	file = {Lyu et al. - 2018 - Remove RATs from Your Code Automated Optimization.pdf:/home/rodger/Zotero/storage/BT5SZSAW/Lyu et al. - 2018 - Remove RATs from Your Code Automated Optimization.pdf:application/pdf}
}

@patent{abadi_fixing_2018,
	title = {Fixing anti-patterns in javascript},
	url = {https://patents.google.com/patent/US9983975B2/en},
	nationality = {US},
	language = {en},
	assignee = {International Business Machines Corp},
	number = {US9983975B2},
	urldate = {2019-10-13},
	author = {Abadi, Aharon and Abadi, Moria and Ben-Harrush, Idan},
	month = may,
	year = {2018},
	keywords = {static analysis, anti, code instructions, javascript source, source code},
	file = {Fulltext PDF:/home/rodger/Zotero/storage/IR82YY96/Abadi et al. - 2018 - Fixing anti-patterns in javascript.pdf:application/pdf;US9983975.pdf:/home/rodger/Zotero/storage/MTTCSN4R/US9983975.pdf:application/pdf}
}

@article{kessentini_what_2013,
	title = {What you like in design use to correct bad-smells},
	volume = {21},
	issn = {1573-1367},
	url = {https://doi.org/10.1007/s11219-012-9187-6},
	doi = {10.1007/s11219-012-9187-6},
	abstract = {Over the past decades, many techniques and tools have been developed to support maintenance activities in order to improve software quality. One of the most efficient ones is software refactoring to eliminate bad-smells. A majority of existing work propose “standard” refactoring solutions that can be applied by hand for each kind of defect. However, it is difficult to prove or ensure the generality of these solutions to any kind of bad-smells or software codes. In this paper, we propose an approach to correct bad-smells using well-designed code. We use genetic algorithms to generate correction solutions defined as a combination of refactoring operations that maximize, as much as possible, the similarity between the corrected bad-smells and examples of well-designed code. We report the results of an evaluation of our approach using four open-source projects. Our proposal achieved high correction scores by fixing the majority of expected bad-smells.},
	number = {4},
	journal = {Software Quality Journal},
	author = {Kessentini, Marouane and Mahaouachi, Rim and Ghedira, Khaled},
	month = dec,
	year = {2013},
	pages = {551--571},
	file = {Kessentini et al. - 2013 - What you like in design use to correct bad-smells.pdf:/home/rodger/Zotero/storage/SY2BBLVQ/Kessentini et al. - 2013 - What you like in design use to correct bad-smells.pdf:application/pdf}
}

@inproceedings{kaur_predicting_2016,
	title = {Predicting software change-proneness with code smells and class imbalance learning},
	doi = {10.1109/ICACCI.2016.7732136},
	booktitle = {2016 {International} {Conference} on {Advances} in {Computing}, {Communications} and {Informatics} ({ICACCI})},
	author = {Kaur, A. and Kaur, K. and Jain, S.},
	month = sep,
	year = {2016},
	keywords = {Java, software maintenance, code smells, Code smells, class imbalance learning, Class imbalance learning, Couplings, Data collection, Exception handling smells, Informatics, Java based mobile application, learning (artificial intelligence), machine learning techniques, Machine learning techniques, Maintenance engineering, maintenance problems, MOBAC, object-oriented methods, object-oriented software metrics, Software, software change-proneness, Software change-proneness, software metrics, Software metrics},
	pages = {746--754},
	file = {Kaur et al. - 2016 - Predicting software change-proneness with code sme.pdf:/home/rodger/Zotero/storage/877WVPXL/Kaur et al. - 2016 - Predicting software change-proneness with code sme.pdf:application/pdf}
}

@article{pritam_assessment_2019,
	title = {Assessment of {Code} {Smell} for {Predicting} {Class} {Change} {Proneness} {Using} {Machine} {Learning}},
	volume = {7},
	doi = {10.1109/ACCESS.2019.2905133},
	journal = {IEEE Access},
	author = {Pritam, N. and Khari, M. and Son, L. Hoang and Kumar, R. and Jha, S. and Priyadarshini, I. and Abdel-Basset, M. and Long, H. Viet},
	year = {2019},
	keywords = {machine learning, Java, software maintenance, software quality, Software systems, code smell, Tools, learning (artificial intelligence), bagging, Bayes methods, change proneness, class change proneness, Code smell, decision tree, decision trees, Java classes, LogitBoost, Machine learning, machine learning algorithms, Machine learning algorithms, Measurement, multilayer perceptron, multilayer perceptrons, Multilayer perceptrons, naive Bayes classifier, pattern classification, random forest, software change proneness, software systems},
	pages = {37414--37425},
	file = {Pritam et al. - 2019 - Assessment of Code Smell for Predicting Class Chan.pdf:/home/rodger/Zotero/storage/A3RL9PPR/Pritam et al. - 2019 - Assessment of Code Smell for Predicting Class Chan.pdf:application/pdf}
}

@article{arcelli_fontana_comparing_2016,
	title = {Comparing and experimenting machine learning techniques for code smell detection},
	volume = {21},
	issn = {1573-7616},
	url = {https://doi.org/10.1007/s10664-015-9378-4},
	doi = {10.1007/s10664-015-9378-4},
	abstract = {Several code smell detection tools have been developed providing different results, because smells can be subjectively interpreted, and hence detected, in different ways. In this paper, we perform the largest experiment of applying machine learning algorithms to code smells to the best of our knowledge. We experiment 16 different machine-learning algorithms on four code smells (Data Class, Large Class, Feature Envy, Long Method) and 74 software systems, with 1986 manually validated code smell samples. We found that all algorithms achieved high performances in the cross-validation data set, yet the highest performances were obtained by J48 and Random Forest, while the worst performance were achieved by support vector machines. However, the lower prevalence of code smells, i.e., imbalanced data, in the entire data set caused varying performances that need to be addressed in the future studies. We conclude that the application of machine learning to the detection of these code smells can provide high accuracy ({\textgreater}96 \%), and only a hundred training examples are needed to reach at least 95 \% accuracy.},
	number = {3},
	journal = {Empirical Software Engineering},
	author = {Arcelli Fontana, Francesca and Mäntylä, Mika V. and Zanoni, Marco and Marino, Alessandro},
	month = jun,
	year = {2016},
	pages = {1143--1191},
	file = {Arcelli Fontana et al. - 2016 - Comparing and experimenting machine learning techn.pdf:/home/rodger/Zotero/storage/VITXPNLS/Arcelli Fontana et al. - 2016 - Comparing and experimenting machine learning techn.pdf:application/pdf}
}

@article{kaur_sp-j48:_2019,
	title = {{SP}-{J}48: a novel optimization and machine-learning-based approach for solving complex problems: special application in software engineering for detecting code smells},
	issn = {1433-3058},
	url = {https://doi.org/10.1007/s00521-019-04175-z},
	doi = {10.1007/s00521-019-04175-z},
	abstract = {This paper presents a novel hybrid algorithm based on optimization and machine-learning approaches for solving real-life complex problems. The optimization algorithm is inspired from the searching and attacking behaviors of sandpipers, called as Sandpiper Optimization Algorithm (SPOA). These two behaviors are modeled and implemented computationally to emphasize intensification and diversification in the search space. A comparison of the proposed SPOA algorithm is performed with nine competing optimization algorithms over 23 benchmark test functions. The proposed SPOA is further hybridized with B-J48 pruned machine-learning approach for efficiently detecting the code smells from the data set. The results reveal that the proposed technique is able to solve challenging problems and outperforms the other well-known approaches.},
	journal = {Neural Computing and Applications},
	author = {Kaur, Amandeep and Jain, Sushma and Goel, Shivani},
	month = apr,
	year = {2019},
	file = {Kaur et al. - 2019 - SP-J48 a novel optimization and machine-learning-.pdf:/home/rodger/Zotero/storage/LPZQRW34/Kaur et al. - 2019 - SP-J48 a novel optimization and machine-learning-.pdf:application/pdf}
}

@inproceedings{maiga_smurf:_2012,
	title = {{SMURF}: {A} {SVM}-based {Incremental} {Anti}-pattern {Detection} {Approach}},
	doi = {10.1109/WCRE.2012.56},
	booktitle = {2012 19th {Working} {Conference} on {Reverse} {Engineering}},
	author = {Maiga, A. and Ali, N. and Bhattacharya, N. and Sabané, A. and Guéhéneuc, Y. and Aimeur, E.},
	month = oct,
	year = {2012},
	keywords = {software maintenance, Anti-pattern, source code, learning (artificial intelligence), Maintenance engineering, Measurement, Accuracy, BDTEX, DETEX, development activities, empirical software engineering, intersystem configurations, intrasystem configurations, Kernel, machine learning technique, maintenance activities, program comprehension, program diagnostics, program maintenance, SMURF, software development management, software development projects, support vector machines, Support vector machines, SVM-based incremental antipattern detection approach, Training},
	pages = {466--475},
	file = {Maiga et al. - 2012 - SMURF A SVM-based Incremental Anti-pattern Detect.pdf:/home/rodger/Zotero/storage/T7ZKUGWR/Maiga et al. - 2012 - SMURF A SVM-based Incremental Anti-pattern Detect.pdf:application/pdf}
}

@inproceedings{kumar_empirical_2018,
	title = {An {Empirical} {Analysis} on {Web} {Service} {Anti}-pattern {Detection} {Using} a {Machine} {Learning} {Framework}},
	volume = {01},
	doi = {10.1109/COMPSAC.2018.00010},
	booktitle = {2018 {IEEE} 42nd {Annual} {Computer} {Software} and {Applications} {Conference} ({COMPSAC})},
	author = {Kumar, L. and Sureka, A.},
	month = jul,
	year = {2018},
	keywords = {object-oriented programming, static analysis, Tools, learning (artificial intelligence), software metrics, Machine learning, Machine learning algorithms, Measurement, pattern classification, program diagnostics, Anti Patterns, class imbalance problem, classification algorithm, common web-services anti-patterns, complex distributed application, distributed application development, Empirical Software Engineering, Feature extraction, feature ranking techniques, Feature Selection, Fine grained Web service, God object Web service, Imbalanced Learning, Machine Learning, machine learning framework, object oriented source code metrics, Prediction algorithms, Predictive Modeling, Random Forest, real-world web-services, service oriented architecture, Service Oriented Architecture, Software Analytics, source code (software), Source Code Analysis, Source Code Metrics, third-party web-services, Web service anti-pattern detection, Web services, Web Services, web-service level},
	pages = {2--11},
	file = {Kumar and Sureka - 2018 - An Empirical Analysis on Web Service Anti-pattern .pdf:/home/rodger/Zotero/storage/JMMASVJ8/Kumar and Sureka - 2018 - An Empirical Analysis on Web Service Anti-pattern .pdf:application/pdf}
}

@inproceedings{nucci_detecting_2018,
	title = {Detecting code smells using machine learning techniques: {Are} we there yet?},
	doi = {10.1109/SANER.2018.8330266},
	booktitle = {2018 {IEEE} 25th {International} {Conference} on {Software} {Analysis}, {Evolution} and {Reengineering} ({SANER})},
	author = {Nucci, D. Di and Palomba, F. and Tamburri, D. A. and Serebrenik, A. and Lucia, A. De},
	month = mar,
	year = {2018},
	keywords = {software maintenance, Software systems, Tools, learning (artificial intelligence), machine learning techniques, Measurement, Training, Machine Learning, Buildings, code smell detection, Code Smells, Detectors, Empirical Studies, ML techniques, Predictive models, produced source code, Replication Study, single type smell, source code elements},
	pages = {612--621},
	file = {Nucci et al. - 2018 - Detecting code smells using machine learning techn.pdf:/home/rodger/Zotero/storage/HF5I4PIW/Nucci et al. - 2018 - Detecting code smells using machine learning techn.pdf:application/pdf}
}

@article{malhotra_systematic_2015,
	title = {A systematic review of machine learning techniques for software fault prediction},
	volume = {27},
	issn = {1568-4946},
	url = {http://www.sciencedirect.com/science/article/pii/S1568494614005857},
	doi = {https://doi.org/10.1016/j.asoc.2014.11.023},
	abstract = {Background Software fault prediction is the process of developing models that can be used by the software practitioners in the early phases of software development life cycle for detecting faulty constructs such as modules or classes. There are various machine learning techniques used in the past for predicting faults. Method In this study we perform a systematic review of studies from January 1991 to October 2013 in the literature that use the machine learning techniques for software fault prediction. We assess the performance capability of the machine learning techniques in existing research for software fault prediction. We also compare the performance of the machine learning techniques with the statistical techniques and other machine learning techniques. Further the strengths and weaknesses of machine learning techniques are summarized. Results In this paper we have identified 64 primary studies and seven categories of the machine learning techniques. The results prove the prediction capability of the machine learning techniques for classifying module/class as fault prone or not fault prone. The models using the machine learning techniques for estimating software fault proneness outperform the traditional statistical models. Conclusion Based on the results obtained from the systematic review, we conclude that the machine learning techniques have the ability for predicting software fault proneness and can be used by software practitioners and researchers. However, the application of the machine learning techniques in software fault prediction is still limited and more number of studies should be carried out in order to obtain well formed and generalizable results. We provide future guidelines to practitioners and researchers based on the results obtained in this work.},
	journal = {Applied Soft Computing},
	author = {Malhotra, Ruchika},
	year = {2015},
	keywords = {Machine learning, Software fault proneness, Systematic literature review},
	pages = {504 -- 518},
	file = {Malhotra - 2015 - A systematic review of machine learning techniques.pdf:/home/rodger/Zotero/storage/Q5MN86H6/Malhotra - 2015 - A systematic review of machine learning techniques.pdf:application/pdf}
}

@article{fontana_code_2017,
	title = {Code smell severity classification using machine learning techniques},
	volume = {128},
	issn = {0950-7051},
	url = {http://www.sciencedirect.com/science/article/pii/S0950705117301880},
	doi = {https://doi.org/10.1016/j.knosys.2017.04.014},
	abstract = {Several code smells detection tools have been developed providing different results, because smells can be subjectively interpreted and hence detected in different ways. Machine learning techniques have been used for different topics in software engineering, e.g., design pattern detection, code smell detection, bug prediction, recommending systems. In this paper, we focus our attention on the classification of code smell severity through the use of machine learning techniques in different experiments. The severity of code smells is an important factor to take into consideration when reporting code smell detection results, since it allows the prioritization of refactoring efforts. In fact, code smells with high severity can be particularly large and complex, and create larger issues to the maintainability of software a system. In our experiments, we apply several machine learning models, spanning from multinomial classification to regression, plus a method to apply binary classifiers for ordinal classification. In fact, we model code smell severity as an ordinal variable. We take the baseline models from previous work, where we applied binary classification models for code smell detection with good results. We report and compare the performance of the models according to their accuracy and four different performance measures used for the evaluation of ordinal classification techniques. From our results, while the accuracy of the classification of severity is not high as in the binary classification of absence or presence of code smells, the ranking correlation of the actual and predicted severity for the best models reaches 0.88–0.96, measured through Spearman’s ρ.},
	journal = {Knowledge-Based Systems},
	author = {Fontana, Francesca Arcelli and Zanoni, Marco},
	year = {2017},
	keywords = {Machine learning, Code smell severity, Code smells detection, Ordinal classification, Refactoring prioritization},
	pages = {43 -- 58},
	file = {Fontana and Zanoni - 2017 - Code smell severity classification using machine l.pdf:/home/rodger/Zotero/storage/D3D7RK4E/Fontana and Zanoni - 2017 - Code smell severity classification using machine l.pdf:application/pdf}
}

@article{arcelli_fontana_comparing_2016-1,
	title = {Comparing and experimenting machine learning techniques for code smell detection},
	volume = {21},
	issn = {1573-7616},
	url = {https://doi.org/10.1007/s10664-015-9378-4},
	doi = {10.1007/s10664-015-9378-4},
	abstract = {Several code smell detection tools have been developed providing different results, because smells can be subjectively interpreted, and hence detected, in different ways. In this paper, we perform the largest experiment of applying machine learning algorithms to code smells to the best of our knowledge. We experiment 16 different machine-learning algorithms on four code smells (Data Class, Large Class, Feature Envy, Long Method) and 74 software systems, with 1986 manually validated code smell samples. We found that all algorithms achieved high performances in the cross-validation data set, yet the highest performances were obtained by J48 and Random Forest, while the worst performance were achieved by support vector machines. However, the lower prevalence of code smells, i.e., imbalanced data, in the entire data set caused varying performances that need to be addressed in the future studies. We conclude that the application of machine learning to the detection of these code smells can provide high accuracy ({\textgreater}96 \%), and only a hundred training examples are needed to reach at least 95 \% accuracy.},
	number = {3},
	journal = {Empirical Software Engineering},
	author = {Arcelli Fontana, Francesca and Mäntylä, Mika V. and Zanoni, Marco and Marino, Alessandro},
	month = jun,
	year = {2016},
	pages = {1143--1191},
	file = {Arcelli Fontana et al. - 2016 - Comparing and experimenting machine learning techn.pdf:/home/rodger/Zotero/storage/CKV5YPIB/Arcelli Fontana et al. - 2016 - Comparing and experimenting machine learning techn.pdf:application/pdf}
}

@book{noauthor_findings_2019,
	title = {Findings from {FUMEC} {University} {Provides} {New} {Data} on {Machine} {Learning} ({Machine} {Learning} {Techniques} for {Code} {Smells} {Detection}: a {Systematic} {Mapping} {Study})},
	isbn = {1945-8711},
	language = {English},
	year = {2019},
	keywords = {Machine learning, Methods, Reports, Research},
	file = {2019 - Findings from FUMEC University Provides New Data o.pdf:/home/rodger/Zotero/storage/97Z9IF3H/2019 - Findings from FUMEC University Provides New Data o.pdf:application/pdf}
}

@inproceedings{azadi_poster:_2018,
	title = {Poster: machine learning based code smell detection through {WekaNose}},
	booktitle = {2018 {IEEE}/{ACM} 40th {International} {Conference} on {Software} {Engineering}: {Companion} {Proceedings} ({ICSE}-{Companion})},
	publisher = {IEEE},
	author = {Azadi, Umberto and Fontana, Francesca Arcelli and Zanoni, Marco},
	year = {2018},
	pages = {288--289},
	file = {Azadi et al. - 2018 - Poster machine learning based code smell detectio.pdf:/home/rodger/Zotero/storage/NGDNE62W/Azadi et al. - 2018 - Poster machine learning based code smell detectio.pdf:application/pdf}
}

@article{kessentini_understanding_2019,
	title = {Understanding the {Correlation} between {Code} {Smells} {And} {Software} {Bugs}},
	author = {Kessentini, Marouane},
	year = {2019},
	file = {Kessentini - 2019 - Understanding the Correlation between Code Smells .pdf:/home/rodger/Zotero/storage/9PD3AI5M/Kessentini - 2019 - Understanding the Correlation between Code Smells .pdf:application/pdf}
}

@article{barbez_machine-learning_2019,
	title = {A {Machine}-learning {Based} {Ensemble} {Method} {For} {Anti}-patterns {Detection}},
	volume = {abs/1903.01899},
	url = {http://arxiv.org/abs/1903.01899},
	journal = {CoRR},
	author = {Barbez, Antoine and Khomh, Foutse and Guéhéneuc, Yann-Gaël},
	year = {2019},
	file = {Barbez et al. - 2019 - A Machine-learning Based Ensemble Method For Anti-.pdf:/home/rodger/Zotero/storage/944KW2V6/Barbez et al. - 2019 - A Machine-learning Based Ensemble Method For Anti-.pdf:application/pdf}
}

@techreport{saluja_assessing_2019,
	address = {Rochester, NY},
	type = {{SSRN} {Scholarly} {Paper}},
	title = {Assessing {Quality} by {Anti}-pattern {Detection} in {Web} {Services}},
	url = {https://papers.ssrn.com/abstract=3350876},
	abstract = {Design pattern plays an important role in development of a good quality software system. Service oriented architecture forms the basis for designing web services. Web services must be carefully designed taking into consideration the quality of service parameters like delay, throughput, reliability and cost. In order to maintain QOS design patterns should be analyzed to detect antipatterns, which can hinder the quality of software system. An antipattern is something, which initially appears like a good indication but creates negative results .The analysis can be done on the basis of several metrics. The paper takes into consideration the web service description files collected from various reliable sources and analyze the same based on static metric content. The static metrics used in this research paper are standard CKJM metrics. The future scope of the paper will focus on detection of antipattern based on dynamic metrics e.g. response time.},
	language = {en},
	number = {ID 3350876},
	urldate = {2019-10-12},
	institution = {Social Science Research Network},
	author = {Saluja, Shivani and Batra, Usha},
	month = mar,
	year = {2019},
	keywords = {Antipattern, Software Quality},
	file = {Saluja and Batra - 2019 - Assessing Quality by Anti-pattern Detection in Web.pdf:/home/rodger/Zotero/storage/VF6F5XXH/Saluja and Batra - 2019 - Assessing Quality by Anti-pattern Detection in Web.pdf:application/pdf;Snapshot:/home/rodger/Zotero/storage/XK39YKBF/papers.html:text/html}
}

@article{song_empirical_2018,
	title = {An {Empirical} {Study} on {Data} {Flow} {Bugs} in {Business} {Processes}},
	doi = {10.1109/TCC.2018.2844247},
	journal = {IEEE Transactions on Cloud Computing},
	author = {Song, W. and Zhang, C. and Jacobsen, H.},
	year = {2018},
	keywords = {empirical study, Cloud computing, Measurement, Prediction algorithms, Business, classification, complexity metrics, Complexity theory, Computer bugs, data flow bugs, Process control, WS-BPEL process},
	pages = {1--1},
	file = {Song et al. - 2018 - An Empirical Study on Data Flow Bugs in Business P.pdf:/home/rodger/Zotero/storage/LARNEIVR/Song et al. - 2018 - An Empirical Study on Data Flow Bugs in Business P.pdf:application/pdf}
}

@article{azeem_machine_2019,
	title = {Machine learning techniques for code smell detection: {A} systematic literature review and meta-analysis},
	volume = {108},
	issn = {0950-5849},
	url = {http://www.sciencedirect.com/science/article/pii/S0950584918302623},
	doi = {https://doi.org/10.1016/j.infsof.2018.12.009},
	abstract = {Background: Code smells indicate suboptimal design or implementation choices in the source code that often lead it to be more change- and fault-prone. Researchers defined dozens of code smell detectors, which exploit different sources of information to support developers when diagnosing design flaws. Despite their good accuracy, previous work pointed out three important limitations that might preclude the use of code smell detectors in practice: (i) subjectiveness of developers with respect to code smells detected by such tools, (ii) scarce agreement between different detectors, and (iii) difficulties in finding good thresholds to be used for detection. To overcome these limitations, the use of machine learning techniques represents an ever increasing research area. Objective: While the research community carefully studied the methodologies applied by researchers when defining heuristic-based code smell detectors, there is still a noticeable lack of knowledge on how machine learning approaches have been adopted for code smell detection and whether there are points of improvement to allow a better detection of code smells. Our goal is to provide an overview and discuss the usage of machine learning approaches in the field of code smells. Method: This paper presents a Systematic Literature Review (SLR) on Machine Learning Techniques for Code Smell Detection. Our work considers papers published between 2000 and 2017. Starting from an initial set of 2456 papers, we found that 15 of them actually adopted machine learning approaches. We studied them under four different perspectives: (i) code smells considered, (ii) setup of machine learning approaches, (iii) design of the evaluation strategies, and (iv) a meta-analysis on the performance achieved by the models proposed so far. Results: The analyses performed show that God Class, Long Method, Functional Decomposition, and Spaghetti Code have been heavily considered in the literature. Decision Trees and Support Vector Machines are the most commonly used machine learning algorithms for code smell detection. Models based on a large set of independent variables have performed well. JRip and Random Forest are the most effective classifiers in terms of performance. The analyses also reveal the existence of several open issues and challenges that the research community should focus on in the future. Conclusion: Based on our findings, we argue that there is still room for the improvement of machine learning techniques in the context of code smell detection. The open issues emerged in this study can represent the input for researchers interested in developing more powerful techniques.},
	journal = {Information and Software Technology},
	author = {Azeem, Muhammad Ilyas and Palomba, Fabio and Shi, Lin and Wang, Qing},
	year = {2019},
	keywords = {Code smells, Machine learning, Systematic literature review},
	pages = {115 -- 138},
	file = {Azeem et al. - 2019 - Machine learning techniques for code smell detecti.pdf:/home/rodger/Zotero/storage/H35XQS2I/Azeem et al. - 2019 - Machine learning techniques for code smell detecti.pdf:application/pdf}
}

@article{garousi_what_2019,
	title = {What {We} {Know} {About} {Smells} in {Software} {Test} {Code}},
	volume = {36},
	doi = {10.1109/MS.2018.2875843},
	number = {3},
	journal = {IEEE Software},
	author = {Garousi, V. and Kucuk, B. and Felderer, M.},
	month = may,
	year = {2019},
	keywords = {software maintenance, Software testing, source code (software), Automation, Bibliographies, catalog, Encoding, Guidelines, multivocal literature review, production code, program testing, Software development management, software test code, Software tools, systematic literature review, test anti-patterns, test automation, test scripts, test smells, test suites},
	pages = {61--73},
	file = {Garousi et al. - 2019 - What We Know About Smells in Software Test Code.pdf:/home/rodger/Zotero/storage/TSQD6D2R/Garousi et al. - 2019 - What We Know About Smells in Software Test Code.pdf:application/pdf}
}

@article{arcelli_performance-driven_2018,
	title = {Performance-driven software model refactoring},
	volume = {95},
	issn = {0950-5849},
	url = {http://www.sciencedirect.com/science/article/pii/S0950584917301787},
	doi = {https://doi.org/10.1016/j.infsof.2017.09.006},
	abstract = {Context Software refactoring is a common practice aimed at addressing requirements or fixing bugs during the software development. While refactoring related to functional requirements has been widely studied in the last few years, non-functional-driven refactoring is still critical, mostly because non-functional characteristics of software are hard to assess and appropriate refactoring actions can be difficult to identify. In the context of performance, which is the focus of this paper, antipatterns represent effective instruments to tackle this issue, because they document common mistakes leading to performance problems as well as their solutions. Objective In order to effectively reuse the knowledge beyond performance antipatterns, automation is required to detect and remove them. In this paper we introduce a framework that enables, in an unique tool context, the refactoring of software models driven by performance antipattern detection and removal. Method We have implemented, within the EPSILON platform, detection rules and refactoring actions on UML models for a set of well-known performance antipatterns. By exploiting the EPSILON languages to check properties and apply refactoring on models, we enable three types of refactoring sessions. Results We experiment our framework on a Botanical Garden Management System to show, on one side, that antipatterns can effectively drive software refactoring towards models that satisfy performance requirements and, on the other side, that the automation introduced by EPSILON-based sessions enables to inspect multiple paths and to propose a variety of solutions. Conclusion This work demonstrates that automation in performance-driven software model refactoring can be beneficial, and that performance antipatterns can be powerful instruments in the hands of software engineers for detecting (and solving) performance problems usually hidden to traditional bottleneck analysis. This work also opens the road to the integration of well-known techniques for software refactoring driven by functional requirements with novel techniques addressing non-functional requirements like performance.},
	journal = {Information and Software Technology},
	author = {Arcelli, Davide and Cortellessa, Vittorio and Pompeo, Daniele Di},
	year = {2018},
	keywords = {Model-driven engineering, Performance antipatterns, Performance engineering, Software refactoring, UML},
	pages = {366 -- 397},
	file = {Arcelli et al. - 2018 - Performance-driven software model refactoring.pdf:/home/rodger/Zotero/storage/S4HFG5SS/Arcelli et al. - 2018 - Performance-driven software model refactoring.pdf:application/pdf}
}